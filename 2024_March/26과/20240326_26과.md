# Today I Learned 20240326 - 모던 자바스크립트 딥다이브 26과 ES6 함수의 추가 기능

## 26-1 함수의 구분
```javascript
var foo = function() {
    return 1;
};

// 일반적인 함수로서 호출
foo(); // 1

// 생성자 함수로서 호출
new foo(); // => foo {}

// 메서드로서 호출
var obj = { 
    foo: foo
};
obj.foo(); // 1
```
- ES6 이전 버전까지 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.
- 별다른 구분 없이 사용할 수 있는 ES6 이전의 함수 특징 덕분에 다양한 목적으로 사용할 수 있지만, 실수를 유발시킬 수 있고 성능 면에서 손해를 볼 수 있다.
- ES6 이전의 모든 함수는 **`callable(호출할 수 있는 함수 객체)`** 이면서 **`constructor(인스턴스를 생성할 수 있는 함수 객체)`** 이다.
    - 객체에 바인딩된 함수가 **`constructor`** 라는 것은 객체에 바인딩된 함수가 **`prototype`** 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미한다.
> ES6 함수의 구분

| ES6 함수의 구분/ES6 함수의 특징 | constructor | prototype | super | arguments |
| :-: | :-: | :-: | :-: | :-: |
| 일반 함수(Normal) | ⭕ | ⭕ | ❌ | ⭕ |
| 메서드(Method) | ❌ | ❌ | ⭕ | ⭕ |
| 화살표 함수(Arrow) | ❌ | ❌ | ❌ | ❌ |

## 26-2 메서드
```javascript
const obj = {
    x: 1,

    // foo 프로퍼티는 메서드.
    foo() { return this.x; }

    // bar 프로퍼티에 연결된 함수는 메서드가 아닌 일반 함수.
    bar: function() { return this.x; }
};

console.log(obj.foo()); // 1
console.log(obj.bar()); // 1

new obj.foo(); // Uncaught TypeError: obj.foo is not a constructor
new obj.bar(); // bar {}

// obj.foo는 constructor가 아닌 ES6 메서드이므로 prototype 프로퍼티가 없다.
obj.foo.hasOwnProperty('prototype'); // false

// obj.bar는 constructor인 일반 함수이므로 prototype 프로퍼티가 있다.
obj.bar.hasOwnProperty('prototype'); // true
```
- ES6 버전부터 메서드는 **<ins>메서드 축약 표현(method shorthand)으로 정의된 함수</ins>** 만을 의미하게 됐다.
- ES6 버전에서 정의한 메서드(이하 **ES6 메서드** )는 인스턴스를 생성할 수 없는 **non-constructor** 다. 그래서 ES6 메서드는 생성자 함수로서 호출할 수 없다.
- ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.

```javascript
const base = {
    name: 'Jung',
    sayHi() {
        return `Hi! ${this.name}`;
    }
};

const derived = {
    __proto__: base,
    /*
    sayHi는 ES6 메서드다. ES6 메서드는 [[HomeObject]]를 갖는다.
    sayHi의 [[HomeObject]]는 sayHi가 바인딩된 객체인 derived를 가리키고,
    super는 sayHi의 [[HomeObject]]의 프로토타입인 base를 가리킨다.
    */
   sayHi() {
        return `${super.sayHi()}. how are you doing?`;
   }
};

console.log(derived.sayHi()); // Hi! Jung. how are you doing?
```

- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 **`[[HomeObject]]`** 를 갖는다.
    - ES6 메서드의 내부 슬롯인 **`[[HomeObject]]`** 는 상위 클래스의 메서드를 참조한다.
    - 그래서 ES6 메서드는 super 키워드를 사용하여 상위 클래스의 메서드를 불러올 수 있다.
- 메서드를 정의할 때는 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 버전 이전의 방식은 사용하지 않는 것을 권장한다.

## 26-3 화살표 함수
- **`화살표 함수(arrow function)`** 의 정의: function 키워드 대신 화살표( **=>** , **fat arrow** )를 사용하여 기존의 함수 정의 방식보다 간략하게 생성하는 함수
    - 화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기존의 함수보다 간략하다.

```javascript
const multiply = (x, y) => x + y;
multiply(2, 3); // 5

const onePar = a => a**2;
onePar(3); // 9

const noPar = () => console.log('no parameter');
noPar(); // 'no parameter'

// concise body(간결한 몸체)
const power = x => x**3;
power(4); // 64

// 위 코드는 다음과 같다.
// block body
const power = x => { return x**3; };
power(4); // 64

// Uncaught SyntaxError: Unexpected token 'const'
const arrow = () => const x = 1;

// 위 코드는 다음과 같다.
const arrow = () => { const x = 1; };

const objLiteral = (id, content) => ({ id, content});
objLiteral(1, 'JavaScript'); // => {id: 1, content: 'JavaScript'}

// 위 코드는 다음과 같다.
const objLiteral = (id, content) => { return { id, content }; };
objLiteral(1, 'JavaScript');

// { id, content }를 함수 몸체 내의 쉼표 연산자문으로 해석한다.
const objLiteral = (id, content) => { id, content };
objLiteral(1, 'JavaScript'); // undefined

const person = (name => ({
    sayHi() { return `Hi? My name is ${name}.`; }
}))('Jung');
```
- 화살표 함수의 함수 정의
    - 화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 하고, 호출 방식은 기존 함수와 동일하다.
- 화살표 함수의 매개변수 선언
    - 매개변수가 한 개일 경우 소괄호 **`()`** 를 생략한다.
    - 매개변수가 두 개 이상일 경우 소괄호 안에 매개변수를 선언한다.
    - 매개변수가 없는 경우 소괄호를 생략할 수 없다.
- 화살표 함수의 함수 몸체 정의
    - 함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 **`{}`** 를 생략할 수 있다.
    - 다만 중괄호를 생략했을 때 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생할 수 있다. 표현식이 아닌 문은 반환을 할 수가 없다.
    - 객체 리터럴을 반환하는 경우 객체 리터럴을 소괄호 **`()`** 로 감싸 줘야 한다.
    - 반환하는 객체 리터럴을 소괄호로 감싸지 않으면 객체 리터럴의 중괄호 **`{}`** 를 함수 몸체를 감싸는 중괄호 **`{}`** 잘못 해석한다.

    > 쉼표 연산자(comma operator): 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환하는 연산자

    - 함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 **`{}`** 를 생략할 수 없다. 이때 반환값이 있다면 명시적으로 반환해야 한다.
    - 화살표 함수도 즉시 실행 함수(IIFE)로 사용할 수 있다.

## 26-4 Rest 파라미터

## 26-5 매개변수 기본값