# Today I Learned 20240312 - 모던 자바스크립트 딥다이브 25장 클래스

## 25-1 클래스는 프로토타입의 문법적 설탕인가?
- JavaScript의 클래스(Class)는 Java나 C#과 같은 클래스 기반 객체지향 프로그래밍에 익숙한 개발자가 더욱 빠르게 학습할 수 있도록 ES6 버전부터 도입된 기능이다.
- JavaScript의 클래스는 Java나 C#의 클래스와 유사한 객체 생성 메커니즘을 가지고 있다.
- JavaScript의 클래스는 기존에 JavaScript가 가지고 있던 프로토타입 기반 객체지향 모델을 대체하는 것이 아니라 클래스 기반 패턴처럼 사용할 수 있도록 하는 **문법적 설탕(syntatic sugar)** 이라고 볼 수 있다.
- JavaScript 클래스의 **`extends`** 와 **`super`** 키워드는 프로토타입과 비교하면 상속 관계 구현을 더욱 간결하고 명료하게 한다.

- JavaScript 클래스와 생성자 함수의 차이점
    - 클래스는 **`new`** 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수를 **`new`** 연산자 없이 호출하면 일반 함수로서 호출한다.
    - 클래스는 상속을 지원하는 **`extends`** 와 **`super`** 키워드를 제공한다. 하지만 생성자 함수는 **`extends`** , **`super`** 키워드를 지원하지 않는다.
    - 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 그러나 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
    - 클래스의 중괄호 내부에는 암묵적으로 **`strict mode`** 가 지정되어 실행되며 **`strict mode`** 를 해제할 수 없다. 하지만 생성자 함수는 암묵적으로 **`strict mode`** 가 지정되지 않는다.
    - 클래스의 **`constructor`** , 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 **`[[Enumerable]]`** 의 값이 **`false`** 인데 각 항목들이 열거되지 않는 것을 의미한다.

## 25-2 클래스 정의
- 클래스는 **`class`** 키워드를 사용하여 정의한다.
- 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스( **`PascalCase`** )를 사용하는 것이 관례다.
- 하지만 파스칼 케이스로 클래스 이름을 작성하지 않는다고 에러가 발생하지 않는다.
```javascript
// 클래스 선언문
class Person {}
```

- 자주 사용하지는 않지만 표현식 방식으로 클래스를 정의할 수 있다.
- 표현식 방식으로 정의한 클래스는 함수와 마찬가지로 기명 클래스 또는 익명 클래스가 될 수 있다.
```javascript
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class Mine {};
```

- 클래스도 함수처럼 **일급 객체(first-class object)** 이기 때문에 값처럼 사용 가능하다.
- **클래스가 일급 객체로서 가지고 있는 특징**
    - 무명의 리터럴로 생성 가능하다. 즉, 런타임에 생성이 가능하다( **`변수 할당문, 객체의 프로퍼티 값, 배열의 요소, 함수 호출의 인수, 함수 반환문`** )
    - 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
    - 함수의 매개변수에 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.

- 클래스의 코드 블록(몸체)에는 0개 이상의 메서드만 정의할 수 있다.
- 클래스의 코드 블록에서 정의할 수 있는 메서드는 **`constructor(생성자)`** , 프로토타입 메서드, 정적 메서드의 세 가지가 있다.
```javascript
// 클래스 선언문
class Person {
    // 생성자
    constructor(name) {
        // 인스턴스 생성 및 초기화
        this.name = name; // JavaScript의 프로퍼티는 기본적으로 public 접근 제한 권한을 가지고 있다.
    }

    // 프로토타입 메서드
    sayHi() {
        console.log(`Hi! My name is ${this.name}`);
    }

    // 정적 메서드
    static sayHello() {
        console.log('Hello!');
    }
}

// 인스턴스 생성
const me = new Person('Jung');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Jung

// 프로토타입 메서드 호출
me.sayHi(); //

// 정적 메서드 호출
Person.sayHello(); //
```

### 클래스와 생성자 함수의 정의 방식 비교

| 정의 방식 | 클래스 | 생성자 함수 |
| :-: | :-: | :-: |
| 생성자 | function **`생성자 함수명`** (param) { this. **`프로퍼티명`** = param; } | constructor(param) { this. **`프로퍼티명`** = param; } |
| 프로토타입 메서드 | **`생성자 함수명`** .prototype. **`프로토타입 메서드명`** = function () { ... }; | **`프로토타입 메서드명`** () { ... } |
| 정적 메서드 | **`생성자 함수명`** . **`정적 메서드명`** = function () { ... }; | static **`정적 메서드명`** () { ... } |

## 25-3 클래스 호이스팅
- 클래스는 함수로 평가받는다.
- 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가 단계에서 평가되어 함수 객체를 생성한다.
- 소스코드 평가 단계에서 평가되어 생성한 함수 객체는 생성자 함수로서 호출할 수 있는 함수인 **`constructor`** 다.
- 클래스의 **`constructor`** 처럼 생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 같이 생성된다.
- **<ins>생성자 함수와 프로토타입은 항상 쌍(pair)으로 존재한다.</ins>**
```javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function 
```

- 클래스는 let, const 키워드로 선언한 변수처럼 클래스 정의 이전에 참조할 수 없다.
- 클래스 선언문도 let, const 키워드로 선언한 변수처럼 호이스팅이 발생하지만 선언문 이전에 일시적 사각지대( **Temporal Dead Zone** )에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.
- var, let, const, class, function 키워드 뿐만 아니라 제너레이터 함수 선언 키워드인 **`function*`** 를 사용하여 선언된 모든 식별자는 호이스팅된다.
- 모든 선언문은 소스코드 평가 단계에서 객체를 생성한다.
```javascript
console.log(People);
// Uncaught ReferenceError: People is not defined
/*
    클래스 선언문의 일시적 사각지대(TDZ)
*/
// 클래스 선언문
class People {}

const Person = '1';

{
    // 호이스팅이 발생하지 않는다면 '1'이 출력되어야 한다.
    console.log(Person);
    // Uncaught ReferenceError: Cannot access 'Person' before initialization

    // 클래스 선언문
    class Person {}
}
```

## 25-4 인스턴스 생성
- 클래스는 생성자 함수이며 **`new`** 연산자와 함께 호출되어 인스턴스를 생성한다.
```javascript
class Person {
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }

    sayHi() {
        console.log(`Hi! My name is ${this.name}. I'm ${this.age}`);
    }
}

// 인스턴스 생성
const me = new Person('Jung', 30);
console.log(me); // Person {name: 'Jung', age: 30}
me.sayHi(); // Hi! My name is Jung. I'm 30
```

- 클래스 인스턴스를 생성할 때 **`new`** 연산자를 사용하지 않으면 에러가 발생한다.
```javascript
class Person {
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }

    sayHi() {
        console.log(`Hi! My name is ${this.name}. I'm ${this.age}`);
    }
}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다.
const me = Person('Jung', 30);
// Uncaught TypeError: Class constructor Person cannot be invoked without 'new'
```

- 클래스 표현식으로 정의된 클래스의 경우 클래스를 가리키는 식별자를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다.
```javascript
const Person = class MyClass {
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }

    sayHi() {
        console.log(`Hi! My name is ${this.name}. I'm ${this.age}`);
    }
};
// 식별자 => Person, 기명 클래스 표현식의 클래스 이름 => MyClass

// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person('Lee', 19);

// 클래스 이름 MyClass는 함수처럼 클래스 코드 블록 안에서만 유효한 식별자다.
console.log(MyClass); // Uncaught ReferenceError: MyClass is not defined

const you = new MyClass(); // Uncaught ReferenceError: MyClass is not defined
```

## 25-5 메서드
- 클래스 몸체(코드 블록)에는 0개 이상의 메서드만 선언할 수 있다.
- 클래스 몸체에서 정의할 수 있는 메서드는 **`constructor(생성자)`** , 프로토타입 메서드, 정적 메서드 3가지가 있다.

### constructor(생성자 함수)
- 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이다.
- **`constructor`** 는 이름을 변경할 수 없다.
- 클래스는 인스턴스를 생성하기 위한 **`constructor`** 라고 볼 수 있다.
- 클래스는 평가되어 함수 객체가 되고, 함수 객체들은 모두 **`prototype`** 프로퍼티를 가지고 있다.
- **`constructor`** 프로퍼티는 클래스 자신을 가리킨다. 이것은 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다.
- **`constructor`** 내부에서 **`this`** 에 추가한 **`name`** 프로퍼티가 클래스가 생성한 인스턴스의 프로퍼티로 추가된다.
- 클래스의 **`constructor`** 메서드와 프로토타입의 **`constructor`** 프로퍼티는 서로 직접적인 관련이 없다. 프로토타입의 **`constructor`** 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킨다.
```javascript
class Animal {
    // 생성자
    constructor(species) {
        this.species = species;
    }
}
```

### 프로토타입 메서드

### 정적 메서드

### 정적 메서드와 프로토타입 메서드의 차이

### 클래스에서 정의한 메서드의 특징

## 25-6 클래스의 인스턴스 생성 과정

## 25-7 프로퍼티

## 25-8 상속에 의한 클래스 확장