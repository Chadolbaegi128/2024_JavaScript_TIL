# Today I Learned 20240312 - 모던 자바스크립트 딥다이브 25장 클래스

## 25-1 클래스는 프로토타입의 문법적 설탕인가?
- JavaScript의 클래스(Class)는 Java나 C#과 같은 클래스 기반 객체지향 프로그래밍에 익숙한 개발자가 더욱 빠르게 학습할 수 있도록 ES6 버전부터 도입된 기능이다.
- JavaScript의 클래스는 Java나 C#의 클래스와 유사한 객체 생성 메커니즘을 가지고 있다.
- JavaScript의 클래스는 기존에 JavaScript가 가지고 있던 프로토타입 기반 객체지향 모델을 대체하는 것이 아니라 클래스 기반 패턴처럼 사용할 수 있도록 하는 **문법적 설탕(syntatic sugar)** 이라고 볼 수 있다.
- JavaScript 클래스의 **`extends`** 와 **`super`** 키워드는 프로토타입과 비교하면 상속 관계 구현을 더욱 간결하고 명료하게 한다.

- JavaScript 클래스와 생성자 함수의 차이점
    - 클래스는 **`new`** 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수를 **`new`** 연산자 없이 호출하면 일반 함수로서 호출한다.
    - 클래스는 상속을 지원하는 **`extends`** 와 **`super`** 키워드를 제공한다. 하지만 생성자 함수는 **`extends`** , **`super`** 키워드를 지원하지 않는다.
    - 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 그러나 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
    - 클래스의 중괄호 내부에는 암묵적으로 **`strict mode`** 가 지정되어 실행되며 **`strict mode`** 를 해제할 수 없다. 하지만 생성자 함수는 암묵적으로 **`strict mode`** 가 지정되지 않는다.
    - 클래스의 **`constructor`** , 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 **`[[Enumerable]]`** 의 값이 **`false`** 인데 각 항목들이 열거되지 않는 것을 의미한다.

## 25-2 클래스 정의
- 클래스는 **`class`** 키워드를 사용하여 정의한다.
- 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스( **`PascalCase`** )를 사용하는 것이 관례다.
- 하지만 파스칼 케이스로 클래스 이름을 작성하지 않는다고 에러가 발생하지 않는다.
```javascript
// 클래스 선언문
class Person {}
```

- 자주 사용하지는 않지만 표현식 방식으로 클래스를 정의할 수 있다.
- 표현식 방식으로 정의한 클래스는 함수와 마찬가지로 기명 클래스 또는 익명 클래스가 될 수 있다.
```javascript
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class Mine {};
```

- 클래스도 함수처럼 **일급 객체(first-class object)** 이기 때문에 값처럼 사용 가능하다.
- **클래스가 일급 객체로서 가지고 있는 특징**
    - 무명의 리터럴로 생성 가능하다. 즉, 런타임에 생성이 가능하다( **`변수 할당문, 객체의 프로퍼티 값, 배열의 요소, 함수 호출의 인수, 함수 반환문`** )
    - 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
    - 함수의 매개변수에 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.

- 클래스의 코드 블록(몸체)에는 0개 이상의 메서드만 정의할 수 있다.
- 클래스의 코드 블록에서 정의할 수 있는 메서드는 **`constructor(생성자)`** , 프로토타입 메서드, 정적 메서드의 세 가지가 있다.
```javascript
// 클래스 선언문
class Person {
    // 생성자
    constructor(name) {
        // 인스턴스 생성 및 초기화
        this.name = name; // JavaScript의 프로퍼티는 기본적으로 public 접근 제한 권한을 가지고 있다.
    }

    // 프로토타입 메서드
    sayHi() {
        console.log(`Hi! My name is ${this.name}`);
    }

    // 정적 메서드
    static sayHello() {
        console.log('Hello!');
    }
}

// 인스턴스 생성
const me = new Person('Jung');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Jung

// 프로토타입 메서드 호출
me.sayHi(); //

// 정적 메서드 호출
Person.sayHello(); //
```

### 클래스와 생성자 함수의 정의 방식 비교

| 정의 방식 | 클래스 | 생성자 함수 |
| :-: | :-: | :-: |
| 생성자 | function **`생성자 함수명`** (param) { this. **`프로퍼티명`** = param } | constructor(param) { this. **`프로퍼티명`** = param } |
| 프로토타입 메서드 | **`생성자 함수명`** .prototype. **`프로토타입 메서드명`** = function () { ... } | **`프로토타입 메서드명`** () { ... } |
| 정적 메서드 | **`생성자 함수명`** . **`정적 메서드명`** = function () { ... } | static **`정적 메서드명`** () { ... } |

## 25-3 클래스 호이스팅

## 25-4 인스턴스 생성

## 25-5 메서드

## 25-6 클래스의 인스턴스 생성 과정

## 25-7 프로퍼티

## 25-8 상속에 의한 클래스 확장