# Today I Learned 3일차(20240304) - 모던 자바스크립트 딥다이브 22장 this

## 22-1 this 키워드
- **`this`**의 정의: 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)
- **`this`**를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

```javascript
// 객체 리터럴
const circle = {
    radius: 5,
    getDiameter() {
        // this는 메서드를 호출한 객체를 가리킨다.
        return 2 * this.radius;
    }
};

console.log(circle.getDiameter()); // 10
```


```javascript
function Circle(radius) {
    // 이 시점에서는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    // 여기에 들어가는 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
    this.radius = radius;
}

Circle.prototype.getDiameter = function () {
    // 이 시점에서는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    // 여기에 들어가는 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
    return 2 * this.radius;
};

// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.
// 인스턴스 생성
const circle = new Circle(5);
```
- 생성자 함수 내부에서는 프로퍼티 또는 메서드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다.
    - 그러나 생성자 함수에 의한 객체 생성 방식은 먼저 생성자 함수를 정의한 이후 **`new`** 연산자와 함께 생성자를 호출하는 단계가 추가로 필요하다. 즉, 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 있어야 한다는 것이다.
    - 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    - 그래서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요한데 그것이 바로 **`this`**다.
- **`this`**는 JavaScript 엔진에 의해 암묵적으로 생성되며 함수를 호출하면 **arguments** 객체와 **this**가 암묵적으로 함수 내부에 전달된다.
- **`this`**가 가리키는 값을 **this 바인딩**이라 부르는데 함수 호출 방식에 의해 동적으로 결정된다.
- 다른 객체지향, 클래스 기반 언어인 Java나 C++에서 **`this`**는 언제나 클래스가 생성한 인스턴스를 가리키지만, JavaScript의 **`this`**는 함수가 호출되는 방식에 따라 **`this`**에 바인딩될 값(this 바인딩)이 동적으로 결정된다.
- **`this`**는 전역에서도 함수 내부에서도 참조할 수 있는 변수이다.
```javascript
console.log(this); // window

function isoTriangle(number) {
    // 일반 함수 내부에서 this는 전역 객체 window를 가리킨다.
    console.log(this); // window
    return (number ** 2)/2;
}

isoTriangle(4); // 8

const person = {
    name: 'Jung',
    getName() {
        // 메서드 내부에서 this는 메서드를 호출한 객체를 가리킨다.
        // 메서드를 호출한 객체(마침표 앞 또는 대괄호 앞의 객체)
        console.log(this); // {name: 'Jung', getName: ƒ}
        return this.name;
    }
};
console.log(person.getName()); // 'Jung'

function Person(name) {
    this.name = name;
    // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
    console.log(this); // Person {name: 'Jung'}
}

const me = new Person('Jung');
```

## 22-2 함수 호출 방식과 this 바인딩
- `this` 바인딩(this에 바인딩될 값)은 함수 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.

### 22-2-1 일반 함수 호출
```javascript
// 웹 브라우저의 전역 객체 => window
// Node.js의 전역 객체 => global
function foo() {
    console.log(`foo's this: ${this}`); // "foo's this: [object Window]"
    function bar() {
        console.log(`bar's this: ${this}`); // "bar's this: [object Window]"
    }
    bar();
}
foo();
```
- 전역 함수 뿐만 아니라 중첩 함수를 일반 함수로 호출하면 함수 내부의 `this`에는 전역 객체가 바인딩된다.
- `strict mode`가 적용될 경우 일반 함수 내부의 `this`에는 `undefined`가 바인딩된다.
```javascript
function foo() {
    'use strict';

    console.log(`foo's this: `, this); // foo's this:  undefined
    function bar() {
        console.log(`bar's this: `, this); // bar's this:  undefined
    }
    bar();
}

foo();
```

```javascript
// var 키워드로 선언한 전역 변수 num은 전역 객체의 프로퍼티이다.
var num = 12;
// const 키워드로 선언한 전역 변수 num은 전역 객체의 프로퍼티이다.
// const num = 12;

const obj = {
    num: 20000,
    cal() {
        console.log("cal's this: ", this); // {num: 20000, cal: ƒ}
        console.log("cal's this.num", this.num); // 20000 => obj 객체에 바인딩됨

        // 메서드 내에서 정의한 중첩 함수
        function com() {
            console.log("bar's this: ", this); // window
            console.log("bar's this.num", this.num); // 12 => 전역 객체에 바인딩됨
        }
        com();
    }
};

obj.cal();

const callbackObj = {
    num: 3000,
    val() {
        console.log("val's this: ", this); // {num: 3000, val: ƒ}
        // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.
        setTimeout(function () {
            console.log("callback's this: ", this); // window
            console.log("callback's this.num", this.num); // 12 => window.num의 값을 참조
        }, 500);
    }
};

callbackObj.val();
```

- 